学习笔记  1

%c 打印单个字符    %d 打印整形（十进制）    %f 打印单精度   %lf 打印双精度
%p 以地址的形式打印      %x 打印十六进制   %s打印字符串  %u  打印无符号十进制整数       %e 打印指数

*： scanf（”%d  %*d  %d“，%a ,&b);输入1 2 3 时，意即吧1 赋予a，2被跳过，3赋予b。    而在%d的%与d之间输入数字，表示指定输入的宽度（即字符数）若输入的字符超过指定数，则超出部分不再取出，留在输入缓冲区内。



常量：1.字面常量 2.const常量（用于修饰变量，使得变量具有常量的属性，但本质上仍然是个变量）  4.枚举常量 （用enum表示。其作用为：将一个范围内的可能类型列举出来，并赋为常量。大括号里的枚举常量不能更改的，但是枚举类型创建出的变量是可以更改的。 example：enum Color color = yellow。其中color可以变，它是一个变量。enum Color是在main函数定义以前就定义好的，这样才能在main函数中使用这些枚举常量。）

字符串中如  "abc"  共有三个字符，而事实上在c后面默认省略了一个\0，\0的意义为表示字符串的结束，它不算一个字符*。\0同样能表示一个数组的结束。

转义字符
\?  在书写连续多个问号时使用，防止他们被解析成三字母词
\'   用于表示字符常量'
\“ 用于表示一个字符串内部的双引号
\\   用于表示一个反斜杠，防止它被解释为一个转义序列符。
\a   警告字符，蜂鸣      \n  换行             \t   垂直制表符
\b   退格符                   \r   回车
\f    进纸符                   \t   水平制表符

例如：\n表示换行
特别的是：\ddd 表示的是ddd作为八进制所代表的十进制的那个数作为ASCII码值转化对应的字符。\ddd占一个字符。
例如：\32 ，八进制32为十进制的26，26对应的符号可查表得
同理有\xdd表示十六进制  同上述描述
如 \x99 表示十六进制中99代表的十进制数作为ASCII码值转化对应的字符。


操作符  = - * /   —  加减乘除      %—取模
<<  >>向左\右移位

（2进制）位操作
&  按位与   将两个二进制数每个位数对应，有一个或两个0则输出0，两个都为1才输出1
example：      按位与  0   1   1             实际在编程时用的是十进制
                                  1   0   1         
                         ->     0   0   1                大意即“0优先”

|    按位或          同理如按位与，但按位或中“1优先”
^  按位异或        对应的二进制位相同则为0
                         对应的二进制位相异则为1


原码  反码  补码
二进制首位为符号位
原码符号位不变，其他位按位取反（1->0  0->1）得到反码
反码加1得到补码

注：符号位 1表示负数 0表示正数。    另外，通常0表示假，非0表示真。

后置++，先使用，再++   前置++，先++，再使用
eg.  int a = 10                   若用前置++则a = b = 11
       int b = a++
打印出来a = 11  b = 10 

逻辑与 - &&  -  有一假则输出假
逻辑或 -   ||    -    有一真则输出真

条件操作符（三目操作符）：     exp1 ? exp2 : exp3;       其中exp1，exp2，exp3表示的是一个表达式
作用是：若第一个表达式为真，则第二个表达式为整式的值；若第一个表达式为假，则第三个表达式为整式的值。
example：max={a > b ? a : b};  意即若a > b成立，则max取a的值；否则取b的值


static  修饰局部/全局变量/函数。
可将局部变量的生命周期变长（使其从在局部函数执行完后自动销毁，变为在程序运行完后再销毁。）
同时会改变变量的作用域，让静态的全局变量只能再自己所在的源文件内部使用，出了原文件就无法再使用了。（无法用extern ……来将另一个文件的函数拿到本文件中使用）
一个普通的函数自带外部链接属性，而再其被static修饰以后，它的链接属性被改变了。
（外部链接属性->内部链接属性）

宏的定义(在主函数之前)：
eg： #include ＜stdio.h＞
          #define  MAX(X,Y) (X>Y?:Y)
         int main()
         {int a = 10;
          int b = 20;
          int max ＝ 0;
          max = MAX(a,b);
          printf("max =%d\n",max);
               return 0;
         }                      

结构体
创建一个结构体，以在后续使用中对复杂对象进行描述。
eg.  :          
struct Book
{
      char name [20];
      short price;
};

int main()
{
         struct Book b1 = {"C语言程序设计" , 55};
         printf("书名：%s\n"  ,  b1.name);
         printf("价格：%d元\n"  , b1.price );                 //即可打印出书b1的书名和价格
         或者
         struct Book* pb = &b1;
         printf("%s\n" , pb -> name);         // 等价于  printf("%s\n"  ,  (*pb). name);    
         printf("%d\n",  pb -> price);
         return 0;
}

结构体变量.成员  结构体指针->成员
一个数组的名字实际指向地址，即其为指针
需用strcpy（）来进行更改   eg. strcpy(b1.name , "更改后的名字")    改函数应引用头文件<string.h>

if （else）语句，如果if/else if/else内要控制多个（>=1）语句，需将语句用大括号包含起来。（即使其成为一个代码块）
“else悬空问题”：else总是和与其最接近的未匹配的if相匹配。
若要使else与想匹配的if匹配，可以用大括号形成代码块以达到目的。

switch语句（允许嵌套使用）：switch语句只能适用于整形变量（即switch（），括号内变量只能为整形变量.)             而case后只能接整形常量。      多单配break一起使用   switch可嵌套使用
break：使程序从break处直接跳出该程序块，不再执行接下来的程序。
若有超出判定的数据，可加default：xxx  进行提示
default可放于任意位置，一般置于末尾

continue：在循环语句中执行continue后，不再执行之后的程序，跳至循环语句开头重新进入循环语句执行程序。
                    
EOF（本质上是- 1 ）：end of file  文件结束标志。（在控制台中 ctrl + z 可以表示EOF，即输入 ctrl + z   可以使程序结束运行）

getchar     scanf   俩输入函数运行时实际上把输入的字符给取走了（输入的东西存在输入缓冲区中，输入函数会到其中去取内容） 另外，若输入内容中有空格，scanf函数只会读取空格以前的内容。 getchar碰到空格只会读取空格然后结束。

#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
int main()
{
       int ret = 0;
       int ch = 0;
       char password[20] = { 0 };
       printf("请输入密码：>");          //：>在此处没有实际意义
       scanf("%s", password);
       while ((ch = getchar()) != '\n')
       {
              ;
       }
       printf("请确认(Y/N):>");
       ret = getchar();
       if (ret == 'Y')
       {
              printf("确认成功\n");
       }
       else
       {
              printf("放弃确认\n");
       };
                      return 0;
       }

上处为一实例

for 循环语句 ：（exp1             ;                exp2                  ;            exp3）
              初始化，只在第一次进入              判断                               调整
              循环体的时执行，循环开          符合条件才继续                  在执行完一遍循环体
              始之后不再执行                       循环                                   之后再执行，之后进
                                                                                                       入判断
                  
for循环的初始化、调整、判断都可以省略。判断如果别省略，判断条件就是恒为真

循环语句判断条件判断的是真和假。即如果判断条件（exp2）是赋值语句，
当所赋值为0时，判断为假，循环语句不执行；赋值为非0时，判断为真,形成死循环

arr[] = "welcome to my world"   ->   字符串，再world的d之后会自动增加\0，使得数组的最大下标“+1”      而char arr[] = {'a' ,'b' },这其中字符1后不会自动追加\0
\0在字符串中占”空间“不占”长度“。   库函数 strlen() 在计算字符串长度时遇\0才停止，没遇到\0将会显示出随机值，比如上方 | 这个例子

数组给函数传参，传的是第一个元素的地址。
example：   int arr[] = {0 , 1}  my_strlen(arr)    即给自定义函数 my_strlen传递的是‘0’的地址   若数组内容是字符串，则传递的是第一个字符的地址。数组中的元素地址是连续的。
       数组名确实能表示首元素的地址，但是有两个例外：1.sizeof（数组名），这里的数组名表示整个数组，计算的是整个数组的大小，单位是字节。 2.&数组名，这里的数组名表示整个数组，取出的是整个数组的地址。（将&arr打印出来依然是首元素地址，但打印&arr+1得到的是跳过整个数组后的地址）

在数组中 char arr[] = {'a' , 98}  98实际代表的是：98这个ASCII码值所代表的字符，即'b'。

二维数组arr【】【】可理解为以一维数组为一个元素的数组。类如（arr【】）【】括号内为数组名，括号外为下标。
二维数组的数组名也表示数组首元素的地址，打印出来是第一个“小元素（下标0,0）”的地址，实际表示第一行整行数组，即第一个“元素（第一行）”。

二维数组初始化时，行列空间设置时，行可省略列不能省略。二维数组行列的下标都是从0开始的。
不完全初始化的数组未初始化的元素默认初始化为0

数组越界访问（访问超出下标界限的元素）编译器不会报错。

sleep（） 括号内填数字（x），以毫秒为单位，程序暂停运行x毫秒
头文件为  #include <windows.h>

system（“cls”）;   -> 清空屏幕      头文件为  #include <stdlib.h>
^
 |   --  执行系统命令         system（“shut - s -t 60”）;->电脑将在60秒后关机  system（"shutdown - s - a"）;取消关机

strlen() -> 计算字符串的长度  头文件为  #include <string.h>

==不能用来比较两个字符串是否相同    可以使用一个库函数-strcmp 来比较
example： strcmp(password, "123456" ）== 0  (password是已经设定好的字符串)
                 //字符串password与字符串“123456”相同 
而如果用一个变量来存储strcmp的值，字符串前者大于后者会输出大于0的数；其拿着小于后者则会输出小于0的数，相等时输出0
头文件为 <string.h>


实际参数（实参):
真实传给函数的参数，叫实参。实参可以是︰常量、变量、表达式、函数等。无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参。当函数不需要传参时，可填void

形式参数（形参) ∶
形式参数是指函数名后括号中的变量，因为形式参数只有在函数被调用的过程中才实例化（分配内存单元），所以叫形式参数。形式参数当函数调用完成之后就自动销毁了。因此形式参数只在函数中有效。

函数调用——嵌套 
链式访问——“反馈调节”“跳步”直接将一个函数的返回值作为另一个函数的输入值

函数模块
在头文件中创建声明，在源文件中进行定义。
在之后编写中便可直接引用该函数模块。格式：#include "xxx.h"

头文件声明一般格式
#ifndef   __XXX_H_
#define  __XXX_H_
                                                   防止一个文件中同一头文件被引用多次
//函数的声明                                而浪费资源

#endif


递归
递归的常见错误：栈溢出（stack overflow）
栈区：局部变量 函数形参
堆区：动态开辟的内存（malloc  calloc）
静态区：全局变量 static修饰的变量
每次调用函数都会调用栈区空间，当空间被耗干，栈溢出，发生错误


资料网站： www.cplusplus.com    http://en.cppreference.com(英文)     http://ch.cppreference.com（中文）  MSDN      交流网站：www.stackoverflow.com         github


函数printf的返回值为字符的个数。（prinf（"%d\n,printf("%d\n", 10)；  ->  最终打印的结果为102）



逗号表达式，优先级别最低，它将两个及其以上的式子联接起来，从左往右逐个计算表达式，整个表达式的值为最后一个表达式的值。
eg.：a=(a=3*5,a*4)的值是60，其中（a=3*5,a*4）的值是60， a的值在逗号表达式里一直是15，最后被逗号表达式赋值为60，a的值最终为60。


支持变长数组的编译器上，数组的大小可以是变量。
在创建该类数组时不能初始化.

操作符
算术操作符+-*/%
除法:整形/浮点型浮点型除数和被除数至少有一个为浮点数e.g.1.0/2取模操作符的两端必须是整数
移位操作符
<<>>左/右移位移动的是二进制位
左移操怍符（仅支持整形)∶左边丢弃，右边补零z左移一位相当于乘二右移操作符
算术移位:右边丢弃左边补原符号位逻辑移位:右边丢弃，左边补ovs煽译器采用算术右移
不同编译器不同
整数的二进制表示有3种原码反码补码正整数的原码反码补码相同
负整数的原码反码补码需经过计算得到e.g.对十进制
00000000000000000000000000000111 原码00000000000000000000000000000111反码00000000000000000000000000000111 补码-7
10000000000000000000000000000111 原码11111111111111111111111111111000反码11111111111111111111111111111001补码整数在内存中存储的是补码
移位操作符操作对象是补码
对于移位运算符，不要移动附属为，这个标准是未定义的。

位操作符(二进制)
&-按位与
l-按位或
-按位异或:相同为0不同为1

"abc" == "abed”这样是在比较两个字符串的首元素地址。(用strcmp)

逻辑操作符
&&左边为假，右边就不计算了
||左边为真，右边就补计算了

三目操作符
表达式1?表达式2:表达式3
1为真输出2，1为假输出3

不要写有多个计算路径的表达式，有潜在的问题。如: a*b + c*d +e等可先算剩法再算加法亦可先计算前面两个剩法后计算第一个加法之后在接着计算剩下的步骤。若表达式中会引起值的i变化就会使式子出现问题。
要主动凸显优先级

指针变量所占内存大小都相同。在32位下为4个字节，在64位下为8个字节。
指针变量类型决定了其解引用时访问几个字节。决定了其+1-1时跳过几个字节，即指针的步长。
变量类型要与指针变量类型对应

野指针
指针指向的位置不可知(随机，不正确等)
成因:1.未初始化。2.指针越界访问。3.指针指向的空间释放。如何规避:1.指针初始化。2.小心指针越界。3.指针指向空间释放即使置NULL。4.避免返回局部变量的地址。5.指针使用之前检查有效性。

指针-指针得到两指针之间元素的个数
不是所有的指针都能相减，只有指向同一空间的指针能相减。允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。

二级指针
存放一个指针变量的地址
(e.g.int* * ppa = &pa (pa为指针)
两个*间的空格可省略。后面一个星表示ppa为指针变量，前面的int*表示指针指向的元素的类型(即类型为int的指针变量）)

空指针不能解引用

浮点数在内存中无法精确存储

1.数组随着下标的增长地址是由低到高变化的。
2.栈区内存的使用习惯是先使用高地址处的空间，再使用低地址的空间。

结构体
相当于创建了一个变量类型，由此创建的变量是结构体变量。创建结构体变量可直接在结构体创建后创建}外;前输名称以，为间隔亦可直接在主函数中创建
结构体成员可为其他结构体的结构体变量，此情况下创建结构体变量时遇到结构体变量以f将其中内容赋值定义。同时在访问时需说明访问路径。(e.g. p.sp.name)
存一个结构体变量的地址的指针称为结构体指针Struct strna*p = &p1
通过地址访问结构体变量时用->
结构体传参时，传结构体的地址能节省空间，提高效率

asssert()  ()内填表达式，判断为假时报错（相当于说必须满足()内的内容。）
利用const避免一些赋值错误。const修饰常量能使其不能被改变。const修饰指针:
1.const放在*的左边(const int* p)，使指针变量指向的对象不能通过该指针来改变。但是该指针变量本身的值使可以改变的。
2.const放在*的右边(int* const p)，使指针变量指向的对象可通过该变量来改变，但是不能修改变量本身的值。
const可同时以上述两种方式使用。

字符的本质是ASCII码值，是整形。
通常int a =...  int前省略了signed，long及long long同。
而char无这种省略。当创建变量如char a=... 是，char到底是signed char还是unsigned char标准是未定义的，取决于编译器的实现。
signed char 范围 -127~128    unsigned char 范围 0~255
signed short -32768~32767   unsigned char 0~65535

可直接用==来判断单个字符是否相等。
浮点数不能直接比较大小，因为其在计算机中的存储并不完全准确。
fabs——求浮点数的绝对值      abs——求整数的绝对值
比较方法： if(fabs(a-b) < 1e-6)
                 printf("a等于b\n");
                 else
                 printf("a不等于b");
float的精度误差在1e-6 double的精度误差在1e-15
即小数点后6位和15位
使用%f格式控制符打印float或double类型数据会默认保留6位小数。以%.nf来说明保留几位小数。

左对齐：在打印数字宽度前面加一个“-”
说明：数字宽度为10，如果打印的位数小于10，则在后面不足空格；如果要打印的位数大于10，则打印所有的数字，不会截断。
e.g：printf("%-10d\n",num)
右对齐则类似
e.g:printf（"%10d",num）
要使打印出的数带正负号，在d前加上“+”即可，无论实际数的正负
打印数的正负号的操作符“+”与 左对齐的“-”同时使用“-”在“+”前
e.g：printf("%-+10d%-+10.2f%-+10d%s\n",a,f,b,"Hello");
左对齐打印正负号，占用10个字符


在计算机系统中，数值一律用补码来表示和存储，原因在于，使用补码，可以将符号位和数值域统一处理
同时，加法和减法也可以统一处理（CPU只有加法器）。此外，补码与远吗相互转换，其运算过程是相同的，不需要额外的硬件电路。

大端字节序存储：把一个数据的高位字节序的内容存放在低地址处，把低位字节序的内容放在高地址处，就是大端字节序存储。
小端字节序存储相反。

char* p = "abcdef";    //把字符串首字符a的地址，赋值给了p
printf（“%s\n”,p）  //也可以这么写，但不安全，因为可通过p解引用改变字符串内容，而实际上字符串是常量，无法被改变，会是程序出错。    建议在char*前加const


指针数组：用来存放指针的数组。     int* p1[]     或 int *p1[]
数组指针：指向数组的指针。           int (*p2)[]  = &arr   ->  该括号内的元素个数必须写清楚，不能不填
数组指针可用于存放二维数组的首元素。二维数组的首元素是它的第一行。
函数指针：指向函数的指针。
对于函数来说，&函数名和函数名都是函数的地址。
e.g:  int (*pf)(int , int) = &Add  （&可省略）第一个int是指函数的返回值的类型。后面的（int ，int）对应形参类型。形参名不一定要写出。
应用：int ret = (*pf)(2 , 3)           或      int ret = pf(2 , 3)       即*可省略     要加*一定要加（）
                                                          上即为正常应用函数的形式

（*(void (*)() )0 ）()
以上代码是一次函数调用，调用的是0作为地址处的函数。

void (*signal(int ,  voide(*)(int) ) )(int)
signal是函数名，以上代码是一次函数声明
声明的signal函数的第一个参数的类型是int，第二参数的类型是函数指针，还函数指针指向的函数参数是int，返回类型是void，signal函数的返回类型也是一个函数指针，该函数指针指向的函数参数是int，返回类型是void。
可以利用typedef来简化表达
typedef void(* pf_t)(int)  ; //把void（*）（int）类型重命名为pf_t
则使用时可化为： pf_t  signal (int , pf_t);
另外的应用：typedef unsigned int uint 将无符号整形命名为uint

函数指针的用途
例：写一个计算器，可以简化冗余代码

函数指针数组
e.g: int (*pf[ ]）( int , int ) = { Add ,Sub,……}

回调函数：
回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数是，我们就说这事回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。



qsort - 快速排序函数
void qsort(void* base , size_t num ,size_t width ,int (* compare)(const void* e1,const void* e2))
                排序数据的   待排序的数  待排序的数据                   函数指针-比较函数
                起始位置      据元素的个  元素的大小                需要自己用函数写出排序方法
                                   数             （单位：字节）           然后传参（函数指针）到此处

void*是无具体类型的指针（泛型），可以接受任意类型的地址
它不能直接进行解引用，也不能+-整数
实际应用中可将其强制类型转换后使用